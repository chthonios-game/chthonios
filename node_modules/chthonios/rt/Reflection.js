var Common = require("chthonios/rt/Common");
var Environment = Common.Environment.load({});

/**
 * @class Reflection
 */
var Reflection = function(env, config, prefs) {
	this.__environment = env;
	this._classDefs = {};
	this._ifaceDefs = {};

	this.RX_SUPER_FIELD = /xyz/.test(function() {
		xyz;
	}) ? /\b_super\b/ : /.*/;

	this.RX_STRIP_FNCCOMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
	this.RX_FNCARGUMENT_NAMES = /([^\s,]+)/g;

	/**
	 * <p>
	 * Define a class type in the Environment. The class definition consists of the prototype object of the class, the
	 * functional constructor of the class and the formal name of the class.
	 * </p>
	 * 
	 * <p>
	 * If a class already exists with the same formal name, the class definition is updated to the new version. <b>This
	 * does not update the prototype or constructor of initialized objects, but calls to obtain the class will return
	 * the new prototype instead.</b> Generally speaking, classes should only be redefined before the server starts.
	 * </p>
	 * 
	 * @member
	 * @param {Object}
	 *            proto The prototype object
	 * @param {Function}
	 *            ctor The functional constructor
	 * @param {String}
	 *            cfn The class formal name
	 */
	this.defineClass = function(proto, ctor, cfn) {
		var tracer = new Error();
		if (this._classDefs === null) // no dict?
			this._classDefs = {}; // create dict
		if (this._classDefs[cfn] === undefined || this._classDefs[cfn] === null) // no table?
			this._classDefs[cfn] = []; // create
		this._classDefs[cfn].push({ // store
			proto : proto, // the prototype...
			ctor : ctor, // ... the constructor callable...
			tracer : tracer.stack,

			toString : function() {
				return cfn + ".Class";
			}
		}); // ... and the defn call stack

		if (config.debug.classes.dictionary_create) {
			console.log("DEBUG_DICT_CREATE", "defineClass", "Defining named class", cfn);
			console.trace("DEBUG_DICT_CREATE", "defineClass", this.defns[cfn]);
		}
		if (config.debug.classes.structure) {
			console.log("DEBUG_CLASS_STR", "Introspect", cfn, "Constructor", proto.constructor);
			if (proto.init !== undefined && proto.init !== null)
				console.log("DEBUG_CLASS_STR", "Introspect", cfn, "Initter", proto.init);
			else
				console.log("DEBUG_CLASS_STR", "Introspect", cfn, "Initter", "[<void>]");
		}
	};

	/**
	 * <p>
	 * Define an interface structure in the Environment. The interface definition consists of a prototype object with
	 * void functions specifying abstract functions and the formal name of the interface.
	 * </p>
	 * 
	 * <p>
	 * If an interface already exists with the same formal name, the interface definition is updated to the new version.
	 * <b>This does not update whether objects are contractually acceptable for the interface specified, but calls to
	 * obtain the interface will return the new prototype instead.</b> Generally speaking, classes should only be
	 * redefined before the server starts.
	 * </p>
	 * 
	 * <p>
	 * An interface declaration would take the following form:
	 * 
	 * <pre>
	 * Reflection.defineInterface({
	 * 	test : function(a, b, c) {
	 * 	}
	 * }, &quot;TestInterface&quot;);
	 * </pre>
	 * 
	 * </p>
	 * 
	 * @member
	 * @param {Object}
	 *            proto The prototype object
	 * @param {Function}
	 *            ctor The functional constructor
	 * @param {String}
	 *            cfn The class formal name
	 */
	this.defineInterface = function(proto, cfn) {
		var tracer = new Error();
		if (this._ifaceDefs === null) // no dict?
			this._ifaceDefs = {}; // create dict
		if (this._ifaceDefs[cfn] === undefined || this._classDefs[cfn] === null) // no table?
			this._ifaceDefs[cfn] = []; // create
		this._ifaceDefs[cfn].push({ // store
			proto : proto, // the prototype...
			tracer : tracer.stack,
			toString : function() {
				return cfn + ".Interface";
			}
		}); // ... and the defn call stack

		if (config.debug.classes.dictionary_create) {
			console.log("DEBUG_DICT_CREATE", "defineInterface", "Defining named interface", cfn);
			console.trace("DEBUG_DICT_CREATE", "defineInterface", this.defns[cfn]);
		}
	};

	/**
	 * <p>
	 * Derive a class from a name string.
	 * </p>
	 * 
	 * @member
	 * @param {String}
	 *            cfn The class formal name.
	 * @returns {Object} The class definition.
	 * @throws NoSuchClassException
	 *             if class not found.
	 * @throws Error
	 *             if Exception class not found.
	 */
	this.fromName = function(cfn) {
		function _noSuchClass(cfn) {
			if (cfn == "Exception") { // calling for Exception?
				if (config.debug.classes.dictionary_usage) // problem?
					console.error("DEBUG_DICT_USE", "fromName", "System called for", cfn, "but could not offer, panic!");
				throw new Error("Class dictionary is corrupt."); // yes, houstin
			}
			if (config.debug.classes.dictionary_usage) // report cfn!
				console.warn("DEBUG_DICT_USE", "fromName", "Class", cfn, "not found!");
			var ex = this.fromName("Exception").ctor; // get exception
			throw (new ex("No such class " + cfn)); // throw new (Exception)
		}

		if (this._classDefs === null) // no classes?
			_noSuchClass(cfn);
		if (this._classDefs[cfn] === undefined || this._classDefs[cfn] === null) // none for name
			_noSuchClass(cfn);
		var map = this._classDefs[cfn]; // get table
		if (map.length == 0) // no classes seen?
			_noSuchClass(cfn);
		return this._classDefs[cfn][map.length - 1]; // latest declaration!
	};

	/**
	 * <p>
	 * Derive an interface from a name string.
	 * </p>
	 * 
	 * @member
	 * @param {String}
	 *            ifn The interface formal name.
	 * @returns {Object} The interface definition.
	 * @throws Exception
	 *             if interface not found.
	 * @throws Error
	 *             if Exception class not found.
	 */
	this.interfaceFromName = function(ifn) {
		function _noSuchIface(ifn) {
			// protected by fromName()
			var ex = this.fromName("Exception").ctor; // get exception
			throw (new ex("No such interface " + ifn)); // throw new (Exception)
		}

		if (this._ifaceDefs === null) // no ifaces?
			_noSuchIface(ifn);
		if (this._ifaceDefs[ifn] === undefined || this._ifaceDefs[ifn] === null) // none for name
			_noSuchIface(ifn);
		var map = this._ifaceDefs[ifn]; // get table
		if (map.length == 0) // no iface seen?
			_noSuchIface(ifn);
		return this._ifaceDefs[ifn][map.length - 1]; // latest declaration!
	};

	/**
	 * Derive the Class of an object with probable prototype o.
	 * 
	 * @member
	 * @param {Object}
	 *            o The object to derive.
	 * @returns {Object|null} The class or null.
	 */
	this.classOf = function(o) {
		if (o === undefined || o === null)
			return null;
		if (o.classinfo !== undefined && o.classinfo !== null) {
			if (o.classinfo.name !== undefined && o.classinfo.name !== null) {
				return this.fromName(o.classinfo.name);
			}
		}

		if (o.prototype !== undefined && o.protype !== null && o.prototype !== o)
			return classOf(o.prototype);
	};

	/**
	 * <p>
	 * Derive the name of a class, a queried class, a metatobject describing a class (from Reflection), or from an
	 * instance of a class.
	 * </p>
	 * 
	 * <p>
	 * If the class name cannot be found, null is returned.
	 * </p>
	 * 
	 * @member
	 * @param {LoadedClass|Object}
	 *            k The loadedclass or object.
	 * @returns {String|null} The name or null.
	 */
	this.nameOf = function(k) {
		// if k is a metaobject describing klass k...
		if (k.proto !== undefined && k.proto !== null)
			if (k.proto.classinfo !== undefined && k.proto.classinfo !== null)
				if (k.proto.classinfo.name !== undefined && k.proto.classinfo.name !== null)
					return k.proto.classinfo.name;

		// if k is a klass k, then use k.prototype...
		if (k.prototype !== undefined && k.prototype !== null)
			if (k.prototype.classinfo !== undefined && k.prototype.classinfo !== null)
				if (k.prototype.classinfo.name !== undefined && k.prototype.classinfo.name !== null)
					return k.prototype.classinfo.name;

		// k is not metaobject or klass??
		console.warn("Reflection", "Reflection.nameOf(Klass)", "Unable to get name of", k);
		return null;
	};

	/**
	 * Derive the parent Class from which the class k descends from (super).
	 * 
	 * @member
	 * @param {LoadedClass}
	 *            k The Class.
	 * @returns {Object|null} The parent Class, or null if there is no parent (root object).
	 */
	this.superOf = function(k) {
		// if k is a metaobject describing klass k...
		if (k.proto !== undefined && k.proto !== null)
			if (k.proto.classinfo !== undefined && k.proto.classinfo !== null) {
				if (k.prototype.classinfo.name !== undefined
						&& (k.prototype.classinfo.name == "Class" || k.prototype.classinfo.name == "Exception"))
					return null;
				if (k.proto.classinfo.supername !== undefined && k.proto.classinfo.supername !== null)
					return this.fromName(k.proto.classinfo.supername);
			}

		// if k is a klass k, then use k.prototype...
		if (k.prototype !== undefined && k.prototype !== null)
			if (k.prototype.classinfo !== undefined && k.prototype.classinfo !== null) {
				if (k.prototype.classinfo.name !== undefined
						&& (k.prototype.classinfo.name == "Class" || k.prototype.classinfo.name == "Exception"))
					return null;
				if (k.prototype.classinfo.supername !== undefined && k.prototype.classinfo.supername !== null)
					return this.fromName(k.prototype.classinfo.supername);
			}

		// if k is an instance of klass k, klassinfo will be attached...
		if (k.classinfo !== undefined && k.classinfo !== null)
			return this.fromName(k.classinfo.supername);

		// k is not metaobject or klass??
		console.warn("Reflection", "Reflection.superOf(Klass)", "Unable to get supertype of", k);
		return null;
	};

	/**
	 * Configures a class as implementing an interface.
	 * 
	 * FIXME: In the future implementor should consider native methods to always contractually satisfy interface
	 * prototypes, since we cannot reliably determine if a function accesses the invocation args directly (ie, by
	 * varargs invocation) within native code.
	 * 
	 * @member
	 * @param {LoadedClass}
	 *            klass The loaded class object.
	 * @param {String}
	 *            ifn The interface formal name.
	 * @returns
	 */
	this.implementor = function(klass, ifn) {
		/*
		 * Since interfaces are contracts, we have to flatten the klass structure into one [fn(),fn()] list so that we
		 * can establish if all fn in ifn are in klass or klass' inheritance tree. If not, klass cannot implement ifn
		 * and we should panic according to whatever error level is set.
		 */

		function __sig(name, params) {
			return name + "(" + params.join(", ") + ")";
		}

		function _notSatisfied(t, klass, ifn, sig) {
			t.__throwVirtual.call(t, "InterfaceUnsatisfiedException", {}, "Class " + klass.prototype.classinfo.name + " missing method "
					+ sig + " from interface " + ifn + ".");
		}

		function _wrongArgCount(t, klass, ifn, sigc, sigd) {
			t.__throwVirtual.call(t, "InterfaceUnsatisfiedException", {}, "Class " + klass.prototype.classinfo.name + " method " + sigc
					+ " declared, required " + sigd + " for interface.");
		}

		// Build the full type hierarchy; this is expensive
		var __lklasses = [], __lmethods = [], __lfields = [];
		this.__walkTree(klass, __lklasses, __lmethods, __lfields);

		// Get the interface specification
		var iface = this.interfaceFromName(ifn);

		// Check the class correctly implements the interface
		for ( var name in iface.proto) {
			var idef = iface.proto[name];
			var iparams = this.__extractParams(idef);

			// What is implemented ?
			var impl = __lmethods[name];
			if (impl === undefined || impl === null) { // nothing?
				_notSatisfied(this, klass, ifn, __sig(name, iparams));
			}

			var ipparams = this.__extractParams(impl.func);
			if (ipparams.length != iparams.length) // wrong arg count?
				_wrongArgCount(this, klass, ifn, __sig(name, ipparams), __sig(name, iparams));
		}

		// Class klass is now contractually able to be referred to under the interface ifn
		var clinfo = this.__cinfoOf(klass);
		if (clinfo.implementing === undefined || clinfo.implementing === null)
			clinfo.implementing = [];
		clinfo.implementing.push(ifn);
	};

	/**
	 * <p>
	 * Queries the list of implemented interfaces on a class. If specified, confirms that the class is an instance of
	 * the specified interface formal name ifn.
	 * </p>
	 * 
	 * @member
	 * @param {Object}
	 *            co The object to get the interfaces of.
	 * @param {null|String}
	 *            ifn The name of the interface to check.
	 * @returns {Object|Boolean} The interface list, or if the interface ifn is implemented by object co.
	 */
	this.implementing = function(co, ifn) {
		var clinfo = this.__cinfoOf(co);
		if (ifn === undefined || ifn === null) {
			return clinfo.implementing;
		} else {
			return (clinfo.implementing.indexOf(ifn) !== -1);
		}
	};

	/**
	 * Access the classinfo of the raw object k. If flag is not set, tries to obtain the rawclass of object k and
	 * returns the rawclass of object k to cinfo to determine the supertype info object.
	 * 
	 * @member
	 * @param {Object}
	 *            k k
	 * @param {null|Boolean}
	 *            flag flag
	 * @returns {Object|null} The classinfo object, or null if no classinfo found for k.
	 */
	this.__cinfoOf = function(k, flag) {
		// if k is a metaobject describing klass k...
		if (k.proto !== undefined && k.proto !== null)
			if (k.proto.classinfo !== undefined && k.proto.classinfo !== null)
				return k.proto.classinfo;

		// if k is a klass k, then use k.prototype...
		if (k.prototype !== undefined && k.prototype !== null)
			if (k.prototype.classinfo !== undefined && k.prototype.classinfo !== null)
				return k.prototype.classinfo;

		if (!flag)
			try {
				var kls = this.classOf(k);
				if (kls !== undefined && kls !== null) {
					return this.__cinfoOf(kls, true);
				}
			} catch (e) {
			}
		return null;
	};

	/**
	 * <p>
	 * Evaluate the inheritance tree of class klass using visitor map kvisitor to keep state. The parents in the tree of
	 * class klass are placed by name into the kvisitor.
	 * </p>
	 * <p>
	 * If mvisitor is provided, method descriptors will be placed into mvisitor indicating the name of the method, the
	 * fval and the class which defined the method. If methods are shadowed by child classes, the shadowed methods are
	 * ignored.
	 * </p>
	 * <p>
	 * If fvisitor is provided, field descriptors will be placed into fvisitor indicating the name of the method, the
	 * fval and the class which defined the method. If fields are shadowed by child classes, the shadowed fields are
	 * ignored.
	 * </p>
	 * 
	 * @member
	 * @param {Object}
	 *            klass The class
	 * @param {Object}
	 *            kvisitor The visitor map
	 * @param {null|Object}
	 *            mvisitor The method visitor map
	 * @param {null|Object}
	 *            fvisitor The field visitor map
	 */
	this.__walkTree = function(klass, kvisitor, mvisitor, fvisitor) {
		Common.assert(kvisitor !== undefined && kvisitor !== null, "no class visitor provided!");
		var klassname = this.nameOf(klass);
		if (klassname === null) {
			console.warn("Reflection", "Reflection.__walkTree", "unable to name node", klass);
			return;
		}
		if (kvisitor.indexOf(klassname) === -1) {
			kvisitor.push(klassname);
			if (mvisitor !== null || fvisitor !== null) {
				var proto = klass.prototype;
				for ( var mbr in proto) {
					var uv = proto[mbr];
					if (typeof uv != "function" && !this.RX_SUPER_FIELD.test(mbr)) {
						if (fvisitor !== null && fvisitor.indexOf(mbr) === -1)
							fvisitor[mbr] = {
								name : mbr,
								val : uv,
								defn : klass
							};
					}
					if (typeof uv == "function") {
						if (mvisitor !== null && mvisitor.indexOf(mbr) === -1)
							mvisitor[mbr] = {
								name : mbr,
								func : uv,
								defn : klass
							};
					}
				}
			}

			var superKlass = this.superOf(klass);
			if (superKlass !== null && superKlass !== klass)
				this.__walkTree(superKlass.ctor, kvisitor, mvisitor, fvisitor);
		}
	};

	/**
	 * Extract the parameter labels from a function.
	 * 
	 * TODO: In the future __extractParams should consider whether varargs invocation is present (via arguments array)
	 * within the function body.
	 * 
	 * @param {Function}
	 *            fn The function
	 * @returns {Object} List of params.
	 */
	this.__extractParams = function(fn) {
		var fnStr = fn.toString().replace(this.RX_STRIP_FNCCOMMENTS, '');
		var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(this.RX_FNCARGUMENT_NAMES);
		if (result === null)
			result = [];
		return result;
	};

	/**
	 * Throw an Exception from the Reflection system with a specified shorthand type, prototype, message and
	 * construction parameters.
	 */
	this.__throwVirtual = function(type, proto, message, params) {
		var virtual = null;
		try {
			virtual = this.fromName(type).ctor;
		} catch (e) { /* void */
		}
		if (virtual === null) {
			var _x1 = {
				init : function(s, n) {
					this._super.call(this, s);
					this.subErr = n;
				}
			};
			if (proto !== null)
				for ( var p in proto)
					_x1[p] = proto[p];
			virtual = this.fromName("Exception").ctor;
			if (virtual === null)
				throw new Error("Reflection core error.");
			virtual = virtual.extend(_x1, type);
		}
		var cparams = [ message ].concat(params);
		var p = Object.create(virtual.prototype);
		virtual.apply(p, cparams);
		throw p;
	};
};

module.exports = {
	/** @type Reflection */
	Reflection : Reflection
};